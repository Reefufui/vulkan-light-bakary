#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout  : enable
//#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
//#extension GL_ARB_separate_shader_objects : enable

#include "hardcoded_sh_basis.h"

#define WORKGROUP_SIZE 16
#define PI 3.1415926538f

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
    int width;
    int height;
} constants;

layout (set = 0, binding = 0, rgba8)  uniform image2D environmentMap;
layout (set = 0, binding = 1, scalar) buffer buff { vec3 coeffs[9]; };

vec3 toVector(float phi, float theta)
{
    float r = sin(theta);
    return normalize(vec3(r * cos(phi), r * sin(phi), cos(theta)));
}

float x2phi(int x)
{
    return 2.f * PI * (float(x) + 0.5f) / float(constants.width);
}

float y2theta(int y)
{
    return PI * (float(y) + 0.5f) / float(constants.height);
}

void main()
{
    if (gl_GlobalInvocationID.x >= constants.width || gl_GlobalInvocationID.y >= constants.height)
        return;

    ivec2 xy  = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    vec3  dir = toVector(x2phi(xy.x), y2theta(xy.y));

    vec3 color = vec3(0.f);

    for (int l = 0; l < 3; ++l)
    {
        for (int m = -l; m < l + 1; ++m)
        {
            color += coeffs[l * (l + 1) + m] * SH(l, m, dir);
        }
    }

    imageStore(environmentMap, xy, vec4(color, 1.f));
}

