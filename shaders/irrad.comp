// constants containing irradiance environmne map
vec4 cAr;
vec4 cAg;
vec4 cAb;
vec4 cBr;
vec4 cBg;
vec4 cBb;
vec4 cC;

vec3 ShadeIrad(vec4 vNormal)
{
    vec3 x1, x2, x3;

    // Linear + constant polynomial terms
    x1.r = dot(cAr, vNormal);
    x1.g = dot(cAg, vNormal);
    x1.b = dot(cAb, vNormal);

    // 4 of the quadratic polynomials
    vec4 vB = vNormal.xyzz * vNormal.yzzx;
    x2.r = dot(cBr,vB);
    x2.g = dot(cBg,vB);
    x2.b = dot(cBb,vB);

    // Final quadratic polynomial
    float vC = vNormal.x*vNormal.x - vNormal.y*vNormal.y;
    x3 = cC.rgb * vC;

    return x1+x2+x3;
}

void SetSHEMapConstants(float* fLight[3], ID3DXEffect* pEffect)
{
    // Lighting environment coefficients
    D3DXVECTOR4 vCoeff[3];
    static const float s_fSqrtPI = float(sqrtf(D3DX_PI));
    const float fC0 = 1.0f / (2.0f * s_fSqrtPI);
    const float fC1 = float(sqrt(3.0f)/(3.0f*s_fSqrtPI));
    const float fC2 = float(sqrt(15.0f)/(8.0f*s_fSqrtPI));
    const float fC3 = float(sqrt(5.0f)/(16.0f*s_fSqrtPI));
    const float fC4 = 0.5f * fC2;

    int iC;
    for( iC=0; iC<3; iC++ )
    {
        vCoeff[iC].x = -fC1*fLight[iC][3];
        vCoeff[iC].y = -fC1*fLight[iC][1];
        vCoeff[iC].z = fC1*fLight[iC][2];
        vCoeff[iC].w = fC0*fLight[iC][0] - fC3*fLight[iC][6];
    }

    pEffect->SetVector( "cAr", &vCoeff[0] );
    pEffect->SetVector( "cAg", &vCoeff[1] );
    pEffect->SetVector( "cAb", &vCoeff[2] );

    for( iC=0; iC<3; iC++ )
    {
        vCoeff[iC].x = fC2*fLight[iC][4];
        vCoeff[iC].y = -fC2*fLight[iC][5];
        vCoeff[iC].z = 3.0f*fC3*fLight[iC][6];
        vCoeff[iC].w = -fC2*fLight[iC][7];
    }

    pEffect->SetVector( "cBr", &vCoeff[0] );
    pEffect->SetVector( "cBg", &vCoeff[1] );
    pEffect->SetVector( "cBb", &vCoeff[2] );
    vCoeff[0].x = fC4*fLight[0][8];
    vCoeff[0].y = fC4*fLight[1][8];
    vCoeff[0].z = fC4*fLight[2][8];
    vCoeff[0].w = 1.0f;
    pEffect->SetVector( "cC", &vCoeff[0] );
}

